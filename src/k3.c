#include <math.h>
#include <R.h>
#include "geom3.h"
#include "functable.h"

/*
	$Revision: 1.1 $	$Date: 2009/11/04 23:54:15 $

	K function of 3D point pattern


	k3trans	  	translation correction

	k3isot		isotropic correction


# /////////////////////////////////////////////
# AUTHOR: Adrian Baddeley, CWI, Amsterdam, 1991.
#
# MODIFIED BY: Adrian Baddeley, Perth 2009.
#
# This software is distributed free
# under the conditions that
# 	(1) it shall not be incorporated
# 	in software that is subsequently sold
# 	(2) the authorship of the software shall
# 	be acknowledged in any publication that
# 	uses results generated by the software
# 	(3) this notice shall remain in place
# 	in each file.
# //////////////////////////////////////////////


*/


void
k3trans(p, n, b, k)
     Point *p;
     int n;
     Box *b;
     Ftable *k;
{
  register int i, j, l, lmin;
  register double dx, dy, dz, dist;
  register double  vx, vy, vz;
  Point *ip, *jp;
  double dt, vol, lambda, denom, term;

  /* compute denominator & initialise numerator*/
  vol = (b->x1 - b->x0) * (b->y1 - b->y0) * (b->z1 - b->z0);
  lambda = ((double) n )/ vol;
  denom = lambda * lambda;

  for(l = 0; l < k->n; l++) {
    (k->denom)[l] = denom;
    (k->num)[l]   = 0.0;
  }

  /* spacing of argument in result vector k */
  dt = (k->t1 - k->t0)/(k->n - 1);

  /* compute numerator */
  for( i = 0; i < n; i++) {
    ip = p + i;
    for(j = i + 1; j < n; j++) {
      jp = p + j;
      dx = jp->x - ip->x;
      dy = jp->y - ip->y;
      dz = jp->z - ip->z;
      dist = sqrt(dx * dx + dy * dy + dz * dz);
      lmin = ceil( (dist - k->t0) / dt );
      if(lmin < 0)
	lmin = 0;

      vx = b->x1 - b->x0 - (dx > 0 ? dx : -dx);
      vy = b->y1 - b->y0 - (dy > 0 ? dy : -dy);
      vz = b->z1 - b->z0 - (dz > 0 ? dz : -dz);
      if(vx >= 0.0 && vy >= 0.0 && vz >= 0.0) {
	  term = 2.0 /(vx * vy * vz);
	  /* 2 because they're ordered pairs */
	  for(l = lmin; l < k->n; l++)
	    (k->num)[l] += term;
      }
    }
  }

  /* compute ratio */
  for(l = 0; l < k->n; l++)
    (k->f)[l] = ((k->denom)[l] > 0.0)?
      (k->num)[l] / (k->denom)[l]
      : 0.0;
}

// New by Galen Vincent 3/4/2019
void
k3translocal(p, n, b, k, f)
     Point *p;
     int n;
     Box *b;
     Ftable *k;
     Ltable *f;
{
  register int i, j, l, lmin, offset;
  register double dx, dy, dz, dist;
  register double  vx, vy, vz;
  Point *ip, *jp;
  double dt, vol, lambda, denom, term, term2;

  /* compute denominator & initialise numerator*/
  vol = (b->x1 - b->x0) * (b->y1 - b->y0) * (b->z1 - b->z0);
  lambda = ((double) n )/ vol;
  denom = lambda * lambda;

  for(l = 0; l < k->n; l++) {
    (k->denom)[l] = denom;
    (k->num)[l]   = 0.0;
  }

  /* spacing of argument in result vector k */
  dt = (k->t1 - k->t0)/(k->n - 1);

  /* compute numerator */
  for( i = 0; i < n; i++) {
    ip = p + i;
    for(j = i + 1; j < n; j++) {
      jp = p + j;
      dx = jp->x - ip->x;
      dy = jp->y - ip->y;
      dz = jp->z - ip->z;
      dist = sqrt(dx * dx + dy * dy + dz * dz);
      lmin = ceil( (dist - k->t0) / dt );
      if(lmin < 0)
	lmin = 0;

      vx = b->x1 - b->x0 - (dx > 0 ? dx : -dx);
      vy = b->y1 - b->y0 - (dy > 0 ? dy : -dy);
      vz = b->z1 - b->z0 - (dz > 0 ? dz : -dz);
      if(vx >= 0.0 && vy >= 0.0 && vz >= 0.0) {
	      term = 2.0 /(vx * vy * vz);
        /* 2 because they're ordered pairs */
        term2 = vol/(vx * vy * vz * lambda);
	      for(l = lmin; l < k->n; l++) {
	        (k->num)[l] += term;
          offset = (k->n) * i + l;
          (f->full)[offset] += term2;
          offset = (k->n) * j + l;
          (f->full)[offset] += term2;
        }
      }
    }
  }

  /* compute ratio */
  for(l = 0; l < k->n; l++){
    (k->f)[l] = ((k->denom)[l] > 0.0)?
      (k->num)[l] / (k->denom)[l]
      : 0.0;
  }
}
