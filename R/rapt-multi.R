#
# This file contains functions for extracting and processing multiple hit data
# for APT.
#

#### indexMultiples ####
#' Returns a list of indicies where the position in the list is the hit
#' multiplicity and the index is of the first hit in the multiple hit event.
#'
#' \code{indexMultiples} extracts the indicies of the \emph{first} hit for every
#' multiplicity in the ATO file. The indicies are sorted into a list that is
#' ordered by multiplicity. This list is then returned.
#'
#' This function uses the \code{parallel} package to speed processing of the ATO
#' file. The argument \code{cl.n} defines the number of cores to use according
#' to \code{\link[parallel]{makeCluster}}.
#'
#' @param ato An ATO data frame. The data frame should be generated by
#'   \code{\link{readATO}}.
#' @param cl.n An integer. The number of cores to use when creating the parallel
#'   cluster with \code{\link[parallel]{makeCluster}}.
#' @seealso \code{\link{multiples}}, \code{\link{readATO}},
#'   \code{\link[parallel]{makeCluster}}.
#'   @export
indexMultiples <- function(ato, cl.n = 3) {
  mu.ind <- sort(unique(
    c(which(diff(ato$pIndex) == 0), which(diff(ato$pIndex) == 0) + 1L)
  ))
  mu.rle <- rle(ato[mu.ind,]$pIndex)
  mu.cl <- parallel::makeCluster(cl.n, type = 'FORK')
  mu.ls <- parallel::parLapply(mu.cl, 1:max(mu.rle$lengths), function(x) {
    ind <- which(mu.rle$lengths == x)
    cum <- cumsum(mu.rle$lengths)
    cum <- c(0L, cum)
    first <- cum[ind] + 1L
    mu <- mu.ind[first]
    return(mu)
  })
  parallel::stopCluster(mu.cl)
  mu.ls[[1]] <- setdiff(1:dim(ato)[1],mu.ind)
  return(mu.ls)
}
#### multiples ####
#' Provides a vector of multiplicity orders; this may be attached to the ATO
#' for further processing.
#'
#' \code{multiples} takes the output list of first hit indicies returned by
#' \code{indexMultiples} and creates a single vector of the multiplicity of each
#' hit.
#'
#' @param mind A list of integers. The output from \code{\link{indexMultiples}}.
#' @return A vector of integers corresponding to the multiplicity of each hit in
#'   the ATO that generated the list. The order corresponds to the order in the
#'   ATO.
#' @seealso \code{\link{indexMultiples}}
#' @export
multiples <- function(mind) {
  multi <- vector()
  full <- lapply(1:length(mind), function(n) {
    sapply(mind[[n]], function(i) {
      i:(i+n-1)
    })
  })
  multi[unlist(full)] <- rep(1:length(full),
                                    times = unlist(lapply(full, length)))
  return(multi)
}
#### saxeyPlot ####
#' Creates a 2D correlation histogram of mass spectra and, optionally, plots it.
#'
#' \code{saxeyPlot} creates a 2D correlation histogram of mass spectra using the
#' index of the first hit of an ATO data frame. The optional plot also shows the
#' corresponding mass spectrum on each axis for easier identification of high
#' intensity areas of the histogram.
#'
#' @param ind A vector of first hit indices for double hits. The list
#'   generated by \code{\link{indexMultiples}} has this vector as its second
#'   entry.
#' @param ato An ATO data frame. This data frame is generated by
#'   \code{\link{readATO}}.
#' @param begin A numeric. The starting mass value of the correlation histogram.
#' @param end A numeric. The ending mass value of the correlation histogram.
#' @param res A numeric. The bin width of the correlation histogram.
#' @param plot.it A logical scalar. Should the result be plotted?
#' @return The output is the same as that of \code{\link[ash]{ash2}}.
#' @seealso \code{\link{indexMultiples}}, \code{\link[ash]{ash2}}
#' @export
saxeyPlot <- function(ind, ato, begin, end, res = 0.25, plot.it = T) {
  rng <- end - begin
  if(rng <= 0)
    stop('Mass spec range must be positive')
  nbin <- round(rng/res)
  bin <- ash::bin2(
    cbind(ato[c(ind, ind+1),'mass'],
          ato[c(ind+1, ind),'mass']),
    matrix(c(begin,begin,end,end),2,2), c(nbin,nbin))
  ash <- ash::ash2(bin, c(1,1))
  if(plot.it) {
    ms <- createSpec(ato[ato$mass >= begin & ato$mass <= end,], res = res)
    sax.old <- par(no.readonly = T)
    plot(0:1, 0:1, type='n', xlab = '', ylab = '', axes = FALSE)
    par(new = T, plt = c(0.11, 0.85, 0.12, 0.85))
    image(ash$x, ash$y, log(ash$z),
          breaks = seq(floor(min(log(ash$z[ash$z > 0]))),
                       floor(max(log(ash$z))),
                       length.out = 256), col = rainbow(255),
          xlab = '', ylab = '', xaxt = 'n', yaxt = 'n'
    )
    axis(1, tck = -0.015, labels = FALSE)
    axis(1, tick = FALSE, line = -0.5)
    mtext('Mass-to-Charge Ratio (Da)', side = 1, line = 1.7)
    axis(2, tck = -0.015, labels = FALSE)
    axis(2, tick = F, line = -0.5, las = 1)
    mtext('Mass-to-Charge Ratio (Da)', side = 2, line = 2)
    # Mass spectrum for second hit
    par(new = T, plt = c(0.11, 0.85, 0.85, 0.95))
    plot(ms@intensity~ms@mass, type = 'l',
         xaxs = 'i', yaxs = 'i', bty = 'n', xaxt = 'n', yaxt = 'n',
         xlab = '', ylab = '')
    # Mass spectrum for first hit
    par(new = T, plt = c(0.85, 0.95, 0.12, 0.85))
    plot(ms@mass~ms@intensity, type = 'l',
         xaxs = 'i', yaxs = 'i', bty = 'n', xaxt = 'n', yaxt = 'n',
         xlab = '', ylab = '')
    par(sax.old)
    par(new = F)
  }
  return(ash)
}

#### houghClean ####
# Stub for Hough Transform cleaning of multiple hit noise
houghClean <- function(sax) {
  dat <- PET::hough(sax$z)
}
