#
# This file contains functions for extracting and processing multiple hit data
# for APT.
#

#### indexMultiples ####
#' Index multiple hits
#'
#' \code{indexMultiples} extracts the indicies of the \emph{first} hit for every
#' multiplicity in the ATO file. The indicies are sorted into a list that is
#' ordered by multiplicity. This list is then returned.
#'
#' This function uses the \code{parallel} package to speed processing of the ATO
#' file. The argument \code{cl.n} defines the number of cores to use according
#' to \code{\link[parallel]{makeCluster}}.
#'
#' @param ato An ATO data frame. The data frame should be generated by
#'   \code{\link{readATO}}.
#' @param cl.n An integer. The number of cores to use when creating the parallel
#'   cluster with \code{\link[parallel]{makeCluster}}.
#' @seealso \code{\link{multiples}}, \code{\link{readATO}},
#'   \code{\link[parallel]{makeCluster}}.
#' @export
indexMultiples <- function(ato, cl.n = 3) {
  mu.ind <- sort(unique(
    c(which(diff(ato$pIndex) == 0), which(diff(ato$pIndex) == 0) + 1L)
  ))
  mu.rle <- rle(ato[mu.ind,]$pIndex)
  if(.Platform$OS.type == "windows") {
    mu.cl <- parallel::makePSOCKcluster(cl.n)
    parallel::clusterExport(mu.cl, c("mu.rle","mu.ind"))
  } else {
    mu.cl <- parallel::makeForkCluster(cl.n)
  }
  mu.ls <- parallel::parLapply(mu.cl, 1:max(mu.rle$lengths), function(x) {
    ind <- which(mu.rle$lengths == x)
    cum <- cumsum(mu.rle$lengths)
    cum <- c(0L, cum)
    first <- cum[ind] + 1L
    mu <- mu.ind[first]
    return(mu)
  })
  parallel::stopCluster(mu.cl)
  mu.ls[[1]] <- setdiff(1:dim(ato)[1],mu.ind)
  return(mu.ls)
}
#### multiples ####
#' Generate a vector of multiplicity orders
#'
#' \code{multiples} takes the output list of first hit indicies returned by
#' \code{indexMultiples} and creates a single vector of the multiplicity of each
#' hit.
#'
#' @param mind A list of integers. The output from \code{\link{indexMultiples}}.
#' @return A vector of integers corresponding to the multiplicity of each hit in
#'   the ATO that generated the list. The order corresponds to the order in the
#'   ATO.
#' @seealso \code{\link{indexMultiples}}
#' @export
multiples <- function(mind) {
  multi <- vector()
  full <- lapply(1:length(mind), function(n) {
    sapply(mind[[n]], function(i) {
      i:(i+n-1)
    })
  })
  multi[unlist(full)] <- rep(1:length(full),
                                    times = unlist(lapply(full, length)))
  return(multi)
}

#### saxeyPlot ####
#' Create a 2D correlation histogram
#'
#' \code{saxeyPlot} creates a 2D correlation histogram of mass spectra using the
#' index of the first hit of an ATO data frame. The optional plot also shows the
#' corresponding mass spectrum on each axis for easier identification of high
#' intensity areas of the histogram.
#'
#' @param ind A vector of first hit indices for double hits. The list
#'   generated by \code{\link{indexMultiples}} has this vector as its second
#'   entry.
#' @param ato An ATO data frame. This data frame is generated by
#'   \code{\link{readATO}}.
#' @param begin A numeric. The starting mass value of the correlation histogram.
#' @param end A numeric. The ending mass value of the correlation histogram.
#' @param res A numeric. The bin width of the correlation histogram.
#' @param plot.it A logical scalar. Should the result be plotted?
#' @return The output is the same as that of \code{\link[ash]{ash2}}.
#'
#' @seealso \code{\link{indexMultiples}}, \code{\link[ash]{ash2}}
#' @references Saxey, D. W. (2011). Correlated ion analysis and the
#' interpretation of atom probe mass spectra. Ultramicroscopy, 111(6), 473-479.
#' \url{https://doi.org/10.1016/j.ultramic.2010.11.021}.
#' @export
saxeyPlot <- function(ind, ato, begin, end, res = 0.25, plot.it = T) {
  rng <- end - begin
  if(rng <= 0)
    stop('Mass spec range must be positive')
  nbin <- round(rng/res)
  bin <- ash::bin2(
    cbind(ato[c(ind, ind+1),'mass'],
          ato[c(ind+1, ind),'mass']),
    matrix(c(begin,begin,end,end),2,2), c(nbin,nbin))
  ash <- ash::ash2(bin, c(1,1))
  if(plot.it) {
    ms <- createSpec(ato[ato$mass >= begin & ato$mass <= end,], res = res)
    sax.old <- par(no.readonly = T)
    plot(0:1, 0:1, type='n', xlab = '', ylab = '', axes = FALSE)
    par(new = T, plt = c(0.11, 0.85, 0.12, 0.85))
    image(ash$x, ash$y, log(ash$z),
          breaks = seq(floor(min(log(ash$z[ash$z > 0]))),
                       floor(max(log(ash$z))),
                       length.out = 256), col = hcl.colors(255),
          xlab = '', ylab = '', xaxt = 'n', yaxt = 'n'
    )
    axis(1, tck = -0.015, labels = FALSE)
    axis(1, tick = FALSE, line = -0.5)
    mtext('Mass-to-Charge Ratio (Da)', side = 1, line = 1.7)
    axis(2, tck = -0.015, labels = FALSE)
    axis(2, tick = F, line = -0.5, las = 1)
    mtext('Mass-to-Charge Ratio (Da)', side = 2, line = 2, las = 0)
    # Mass spectrum for second hit
    par(new = T, plt = c(0.11, 0.85, 0.85, 0.95))
    plot(ms@intensity ~ ms@mass, type = 'l',
         xaxs = 'i', yaxs = 'i', bty = 'n', xaxt = 'n', yaxt = 'n',
         xlab = '', ylab = '')
    # Mass spectrum for first hit
    par(new = T, plt = c(0.85, 0.95, 0.12, 0.85))
    plot(ms@mass~ms@intensity, type = 'l',
         xaxs = 'i', yaxs = 'i', bty = 'n', xaxt = 'n', yaxt = 'n',
         xlab = '', ylab = '')
    par(sax.old)
    par(new = F)
  }
  return(ash)
}

#### dissocTrack ####
#' Parameterized dissociation track on a multiple hit
#'
#' \code{dissocTrack}
#'
#' @references Saxey, D. W. (2011). Correlated ion analysis and the
#' interpretation of atom probe mass spectra. Ultramicroscopy, 111(6), 473-479.
#' \url{https://doi.org/10.1016/j.ultramic.2010.11.021}.
#' @seealso \code{\link{saxeyPlot}}, \code{\link{dissocDensity}}
#'
dissocTrack <- function(v, m, mp) {
  m*(1-v*(1-m/mp))^-1
}

#### dissocTime ####
#' Estimate the dissociation time
#'
#' \code{dissocTime}
#'
#' @references Saxey, D. W. (2011). Correlated ion analysis and the
#' interpretation of atom probe mass spectra. Ultramicroscopy, 111(6), 473-479.
#' \url{https://doi.org/10.1016/j.ultramic.2010.11.021}.
#' @seealso \code{\link{saxeyPlot}}, \code{\link{dissocDensity}}
#'
dissocTime <- function(mp, x0, phi, v0,
                       amu = 1.66053904e-27, el = 1.602176634e-19) {
  Mp <- mp * amu / el
  sqrt(2 * Mp * x0^2 * phi / v0)
}

#### dissocHist ####
#' Project hits along a dissociation track
#'
#' @param sax The output of \code{\link{saxeyPlot}}
#' @param m1 Mass to charge ratio of the first daughter ion
#' @param m2 Mass to charge ratio of the second daughter ion
#' @param mp Mass to charge ratio of the parent ion
#' @param dv Voltage parameter step
#' @param v Voltage parameter series
#' @param drop Should repeated bins be dropped? Defaults to FALSE.
#' @param nbhd The neighborhood of bins to be included. One of: "point",
#'   "rook", or "queen".
#' @param method A function or character string to be matched by
#'   \code{\link{match.fun}} that returns a single value. The density
#'   calculation method used for the neighborhood of each point.
#' @param renorm Should the returned densities be renormalized to sum to 1?
#'   FALSE uses the densities in \code{sax}. Defaults to TRUE. See
#'   \code{\link[ash]{ash2}}.
#'
#' @references Saxey, D. W. (2011). Correlated ion analysis and the
#' interpretation of atom probe mass spectra. Ultramicroscopy, 111(6), 473-479.
#' \url{https://doi.org/10.1016/j.ultramic.2010.11.021}.
#' @seealso \code{\link{saxeyPlot}}, \code{\link{dissocTrack}},
#'   \code{\link[ash]{ash2}}
#'
dissocDensity <- function(sax, m1, m2, mp,
                          dv = NULL, v = NULL, drop = FALSE,
                          nbhd = "point", method = "max", renorm = TRUE) {
  # Need method for discretizing v parameter to get dv
  if (is.null(dv)) {
    stop("dv calculation not implemented")
  }
  if (is.null(v)) {
    v <- seq(0,1,dv)
  }

  # Sample points along the dissociation curve
  x <- dissocTrack(v, m1, mp)
  y <- dissocTrack(v, m2, mp)
  zx <- spatstat.utils::fastFindInterval(x, sax$x)
  zy <- spatstat.utils::fastFindInterval(y, sax$y)
  zc <- zx + zy * 1i
  w <- !duplicated(zc) # used only if drop = TRUE

  # Select values in neighborhood
  if (nbhd == "point") {
    nb <- 0
  } else if (nbhd == "rook") {
    nb <- c(0, 1, -1, 1i, -1i)
  } else if (nbhd == "queen"){
    nb <- c(0, 1, -1, 1i, -1i, 1+1i, 1-1i, -1+1i, -1-1i)
  } else {
    stop(paste("Unknown neighborhood.", sQuote("nbhd"), "should be one of:",
               sQuote("point"), sQuote("rook"), sQuote("queen")))
  }
  reg <- outer(zc, nb, `+`)
  den <- apply(reg, 1, function(r) {
    nx <- Re(r)
    ny <- Im(r)
    d <- sax$z[cbind(nx,ny)]
    f <- match.fun(method) # Summarize values
    f(d)
  })

  # Drop points
  if (drop) {
    v <- v[w]
    den <- den[w]
    # Need to adjust dv so renorm still works...
  }

  # Renormalize densities
  if (renorm) {
    den <- den / sum(den * dv)
  }

  dat <- data.frame(v = v, den = den)
  attr(dat,'mp') <- mp
  attr(dat,'m1') <- m1
  attr(dat,'m2') <- m2
  attr(dat,'nbhd') <- nbhd

  return(dat)
}

#### houghClean ####
# Stub for Hough Transform cleaning of multiple hit noise
# houghClean <- function(sax) {
#
# }
