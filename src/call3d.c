/*
	$Revision: 1.5 $ $Date: 2010/10/24 10:57:02 $

	R interface

	Pass data between R and internally-defined data structures


# /////////////////////////////////////////////
# AUTHOR: Adrian Baddeley, CWI, Amsterdam, 1991.
#
# MODIFIED BY: Adrian Baddeley, Perth 2009
#
# This software is distributed free
# under the conditions that
# 	(1) it shall not be incorporated
# 	in software that is subsequently sold
# 	(2) the authorship of the software shall
# 	be acknowledged in any publication that
# 	uses results generated by the software
# 	(3) this notice shall remain in place
# 	in each file.
# //////////////////////////////////////////////


*/

#include <R.h>
#include "geom3.h"
#include "functable.h"

#undef DEBUG

#ifdef DEBUG
#define DEBUGMESSAGE(S) Rprintf(S);
#else
#define DEBUGMESSAGE(S)
#endif


void k3translocal(Point *p, int n, Box *b, Ftable *k, Ltable *f);


/*
	ALLOCATION OF SPACE FOR STRUCTURES/ARRAYS

	We have defined an alloc() and free() function for each type.

	However, the free() functions currently do nothing,
	because we use R_alloc to allocate transient space,
	which is freed automatically by R.

*/

Ftable *
allocFtable(n)		/* allocate function table of size n */
int	n;
{
  Ftable *x;
  x = (Ftable *) R_alloc(1, sizeof(Ftable));
  x->n = n;
  x->f 	   = (double *) R_alloc(n, sizeof(double));
  x->num   = (double *) R_alloc(n, sizeof(double));
  x->denom = (double *) R_alloc(n, sizeof(double));
  return(x);
}

// New by Galen Vincent 3/4/2019
Ltable *
allocLtable(n)		/* allocate local table of size n (n should be number of points * nrval) */
int	n;
{
  Ltable *x;
  x = (Ltable *) R_alloc(1, sizeof(Ltable));
  x->n = n;
  x->full = (double *) R_alloc(n, sizeof(double));
  return(x);
}

void freeFtable(x) Ftable *x; { }

// New by Galen Vincent 3/4/2019
void freeLtable(x) Ltable *x; { }

Itable	*
allocItable(n)
int	n;
{
  Itable *x;
  x = (Itable *) R_alloc(1, sizeof(Itable));
  x->n     = n;
  x->num   = (int *) R_alloc(n, sizeof(int));
  x->denom = (int *) R_alloc(n, sizeof(int));
  return(x);
}

void freeItable(x) Itable *x; { }

H4table	*
allocH4table(n)
int	n;
{
  H4table *x;
  x = (H4table *) R_alloc(1, sizeof(H4table));
  x->n     = n;
  x->obs   = (int *) R_alloc(n, sizeof(int));
  x->nco   = (int *) R_alloc(n, sizeof(int));
  x->cen   = (int *) R_alloc(n, sizeof(int));
  x->ncc   = (int *) R_alloc(n, sizeof(int));
  return(x);
}

void freeH4table(x) H4table *x; { }

Box	*
allocBox()		/* I know this is ridiculous but it's consistent. */
{
  Box *b;
  b = (Box *) R_alloc(1, sizeof(Box));
  return(b);
}

void freeBox(x) Box *x; { }


Point	*
allocParray(n)		/* allocate array of n Points */
int	n;
{
  Point *p;
  p = (Point *) R_alloc(n, sizeof(Point));
  return(p);
}

void freeParray(x) Point *x; { }

/*
	CREATE AND INITIALISE DATA STORAGE

*/

Ftable *
MakeFtable(t0, t1, n)
     double *t0, *t1;
     int	*n;
{
  Ftable	*tab;
  int	i, nn;

  nn = *n;
  tab = allocFtable(nn);

  tab->t0 = *t0;
  tab->t1 = *t1;

  for(i = 0; i < nn; i++) {
    tab->f[i] = 0.0;
    tab->num[i] = 0;
    tab->denom[i] = 0;
  }
  return(tab);
}

// New by Galen Vincent 3/4/2019
Ltable *
MakeLtable(n, m) /* n = number of points in the pattern, m = nrval */
     int	*n, *m;
{
  Ltable	*tab;
  int	i, nn, mm, tot;

  nn = *n;
  mm = *m;

  tot = nn*mm;

  tab = allocLtable(tot);

  for(i = 0; i < tot; i++) {
    tab->full[i] = 0.0;
  }
  return(tab);
}



/*
	CONVERSION OF DATA TYPES

		R -> internal

	including allocation of internal data types as needed
*/

Point	*
RtoPointarray(x,y,z,n)
     double *x, *y, *z;
     int	*n;
{
  int	i, nn;
  Point	*p;

  nn = *n;
  p = allocParray(nn);

  for(i = 0; i < nn; i++) {
    p[i].x = x[i];
    p[i].y = y[i];
    p[i].z = z[i];
  }
  return(p);
}

Box *
RtoBox(x0, x1, y0, y1, z0, z1)
     double	*x0, *x1, *y0, *y1, *z0, *z1;
{
  Box *b;
  b = allocBox();

  b->x0 = *x0;
  b->x1 = *x1;
  b->y0 = *y0;
  b->y1 = *y1;
  b->z0 = *z0;
  b->z1 = *z1;
  return(b);
}

/*
	CONVERSION OF DATA TYPES

		internal -> R

	Note: it can generally be assumed that the R arguments
	are already allocated vectors of correct length,
	so we do not allocate them.


*/

void
FtabletoR(tab, t0, t1, n, f, num, denom)
     /* internal */
     Ftable	*tab;
     /* R representation */
     double	*t0, *t1;
     int	*n;
     double	*f, *num, *denom;
{
  int	i;

  *t0 = tab->t0;
  *t1 = tab->t1;
  *n = tab->n;

  for(i = 0; i < tab->n; i++) {
    f[i] = tab->f[i];
    num[i] = tab->num[i];
    denom[i] = tab->denom[i];
  }

  freeFtable(tab);
}

// New by Galen Vincent 3/4/2019
void
LtabletoR(tab, full)
     /* internal */
     Ltable	*tab;
     /* R representation */
     double	*full;
{
  int	i;

  for(i = 0; i < tab->n; i++) {
    full[i] = tab->full[i];
  }

  freeLtable(tab);
}




/*
	R CALLING INTERFACE

	These routines are called from R by
	> .C("routine-name", ....)
*/

// New by Galen Vincent 3/4/2019
void
RcallK3local(x,y,z, n, x0, x1, y0, y1, z0, z1, t0, t1, m, f, num, denom, full)

     double *x, *y, *z;	/* points */
     int    *n;

     double *x0, *x1, 	/* box */
            *y0, *y1,
            *z0, *z1;

     double *t0, *t1;	/* Ftable */
     int    *m;
     double *f, *num, *denom;

     double *full; /* Ltable */

{
  Point	*p;
  Box 	*b;
  Ftable	*tab;
  Ltable *ltab;

  p = RtoPointarray(x, y, z, n);
  b = RtoBox(x0, x1, y0, y1, z0, z1);
  tab = MakeFtable(t0, t1, m);
  ltab = MakeLtable(n, m);

  k3translocal(p, (int) *n, b, tab, ltab);

  FtabletoR(tab, t0, t1, m, f, num, denom);
  LtabletoR(ltab, full);
}

